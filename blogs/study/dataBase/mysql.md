---
title: Mysql 进阶之路
date: 2022-05-23
tags:
 - 数据库
categories:
 - 精选
 - 技术栈
---

<!-- TOC -->

- [事务](#%E4%BA%8B%E5%8A%A1)
    - [两个模式](#%E4%B8%A4%E4%B8%AA%E6%A8%A1%E5%BC%8F)
    - [四个特性](#%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7)
    - [三个并发问题](#%E4%B8%89%E4%B8%AA%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98)
    - [四个隔离级别](#%E5%9B%9B%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
- [存储引擎](#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
    - [InnoDB引擎](#innodb%E5%BC%95%E6%93%8E)
    - [MyISAM 引擎（被 MongoDB 代替）](#myisam-%E5%BC%95%E6%93%8E%E8%A2%AB-mongodb-%E4%BB%A3%E6%9B%BF)
    - [Memory 引擎（被 Redis 代替）](#memory-%E5%BC%95%E6%93%8E%E8%A2%AB-redis-%E4%BB%A3%E6%9B%BF)
- [索引](#%E7%B4%A2%E5%BC%95)
    - [索引结构](#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84)
    - [索引分类](#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB)
- [SQL性能分析](#sql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90)
    - [四种手段性能查看](#%E5%9B%9B%E7%A7%8D%E6%89%8B%E6%AE%B5%E6%80%A7%E8%83%BD%E6%9F%A5%E7%9C%8B)
    - [索引查询优化原则](#%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99)
    - [索引设计原则](#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)
- [SQL优化](#sql%E4%BC%98%E5%8C%96)
    - [插入insert优化](#%E6%8F%92%E5%85%A5insert%E4%BC%98%E5%8C%96)
    - [主键优化](#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96)
    - [修改update优化](#%E4%BF%AE%E6%94%B9update%E4%BC%98%E5%8C%96)
    - [order by排序优化](#order-by%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96)
    - [limit 优化](#limit-%E4%BC%98%E5%8C%96)
    - [group by分组优化](#group-by%E5%88%86%E7%BB%84%E4%BC%98%E5%8C%96)
    - [count 优化](#count-%E4%BC%98%E5%8C%96)
- [存储过程](#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B)
    - [概念](#%E6%A6%82%E5%BF%B5)
- [触发器](#%E8%A7%A6%E5%8F%91%E5%99%A8)
    - [概念](#%E6%A6%82%E5%BF%B5)
- [锁](#%E9%94%81)
    - [全局锁](#%E5%85%A8%E5%B1%80%E9%94%81)
    - [表级锁](#%E8%A1%A8%E7%BA%A7%E9%94%81)
    - [行级锁](#%E8%A1%8C%E7%BA%A7%E9%94%81)

<!-- /TOC -->

# 事务

事务是一组操作的组合，把所有操作当做一个整体提交或者回滚，保证完整性和一次性，要么同时成功，要么同时失败。

场景举例：一个银行账户余额管理系统中，A 在账户存入 1000，B 又在该账户取出 900 存入另一个账户，如果在操作过程中，A 存入 1000这个行为执行完毕后系统崩掉，而 B 的账户没有加上取出的 900，就会使得所有账户少计算了 900，使得完整性丧失。此时应该利用事务回滚。

## 两个模式

1. 设置为手动模式使用事务

```sql
select @@autocommit; -- 查询事务是否开启

set @@autocommit = 0; -- 设置为手动提交事务

select ...; -- 查询业务
update ...; -- 更新业务

commit; -- 提交，没有中途异常就直接提交事务

rollback; -- 回滚，中途出现异常则将上面执行的操作回滚
```

2. 设置为自动模式使用事务

```sql
select @@autocommit; -- 查询事务是否开启

set @@autocommit = 1; -- 默认为自动事务

start transaction; -- 开启事务

select ...; -- 查询业务
update ...; -- 更新业务

commit; -- 提交，没有中途异常就直接提交事务

rollback; -- 回滚，中途出现异常则将上面执行的操作回滚
```

## 四个特性

- 原子性（Atomicity）：事务是不可分割的整体，要么全成功要么全失败
- 一致性（Consistency）：事务执行完成后，所有数据保持一致状态（比如银行账户 X 和 Y 要保持余额之和满足条件）
- 隔离性（Isolation）：数据库提供了不同的隔离级别，保证在并发执行时，事务不受其他操作影响
- 持久性（Durability）：事务一旦提交或回滚，在数据库的数据的改变是永久的

## 三个并发问题

- 脏读（读未提交）：所谓脏，就是读坏了，读到了糟糕的数据。有两个线程并发执行，事务 A 对数据进行了修改，但是还没有提交，意味着此修改很有可能回滚，但是此时事务 B 去读取了已经修改的数据，这个数据很有可能回滚，所以称之为脏数据。

- 不可重复读（中间被修改）：所谓不可重复，意味着在事务 A 执行时，由于事务 B 中间修改了数据，导致事务 A 前后两次查询事务结果不一致。

- 幻读（中间被插入）：指仿佛查询到了幻影。意味着在事务 A 执行时，由于事务 B 中间插入了数据，导致事务 A 前后两次查询数据存在性不一致。

## 四个隔离级别

- 读未提交（read uncommitted）：三种并发问题都有可能出现，意味着可以读到未提交的事务修改的数据
  
- 读已提交（read committed）：解决了脏读问题，意味着没有提交的事务修改的数据不能读
  
- 可重复读（repeatable read）（默认）：解决了读未提交和不可重复读的问题
  
- 可串行化（serializable）：所有事务操作串行化，解决了三大问题，但是效率依次降低

```xml
隔离级别                              脏读              不可重复读              幻读

读未提交（read uncommitted）           ✔                   ✔                   ✔
  
读已提交（read committed）             X                   ✔                   ✔                    
  
可重复读（repeatable read）            X                   X                   ✔
  
可串行化（serializable）               X                   X                   X
```

# 存储引擎

Mysql 体系结构
- 连接层：通过连接池，负责与其他客户端（JDBC、PHP、Python等）连接，同时需要做验证（账户密码）、授权（是超级用户还是普通用户，具有能操作哪些表和库的权限）等操作
- 服务层：包括增删改查的接口、查询解析器、缓存等服务
- 引擎层：内部封装了许多引擎，需要使用时调用即可，即 可插拔式存储引擎；不同存储引擎实现的索引不同
- 存储层：对应着真实的磁盘文件、日志等，将其存储在文件系统中，并完成与存储引擎的交互

## InnoDB引擎
是 Mysql 5.5 版本之后的默认存储引擎。
适用于对事务的完整性要求比较高（支持事务），并发时对事务的一致性要求比较高时使用（行级锁）

特点
- 事务
- 行级锁
- 外键

文件 
InnoDB 的每张表都有一个对应的 xxx.ibd 文件，该文件存储了该表的表结构（sdi）、数据、索引。对应的改变参数：innodb_file_per_table

InnoDB 逻辑存储结构
- 表空间
- 段
- 区
- 页
- 行

## MyISAM 引擎（被 MongoDB 代替）
是 Mysql 5.5 版本之前的默认存储引擎。
如果需求主要是读取和插入，很少有修改和删除，对事务的完整性和并发性要求不高时适合。业务中的评论、足迹、日志适合

特点
- 不支持事务
- 支持表级锁，不支持行级锁
- 不支持外键
- 访问速度快

文件
MyISAM 的 xxx.sdi 文件存储表结构； xxx.MYD 存储数据； xxx.MYI 存储索引

## Memory 引擎（被 Redis 代替） 
Memory 引擎的表结构存储在内存中，由于受到硬件问题、断电问题的影响，只能将这些表作为临时表或者缓存使用。
访问速度快，但表大小受限（存储在内存中），不能保证数据安全，通常做缓存

特点
- 内存存放
- Hash 索引（默认）

文件
磁盘中只有 xxx.sdi 存储表结构文件，其余数据存储在内存中

# 索引
索引是帮助 [高效查找数据] 的 [有序] [数据结构]

索引的优缺点
优点：
- 提高检索效率，降低 IO 消耗
- 通过索引列对数据排序，降低排序成本，降低 CPU 消耗

缺点：
- 需要单独开辟索引列的空间，存储该数据结构
- 降低更新表的效率，使得对 insert、update、delete 的效率降低，因为要对索引进行相应操作

## 索引结构
没有特殊说明，所说的索引都是指 B+ 树结构组织的索引

> 二叉搜索树

二叉搜索树（Binary Search Tree）树上的每个结点，都满足其左子树上所有结点的数据域均小于或等于根结点的数据域，右子树上所有结点的数据域均大于根结点的数据域。

缺点：若插入前已经有序，会退化为链表，大数据情况下层级很深，检索速度慢

> 平衡二叉树

也称作AVL树，AVL树本质还是一棵二叉查找树，只是在其基础上增加了“平衡”的要求。所谓平衡是指，对AVL树的任意结点来说，其左子树与右子树的高度之差的绝对值不超过1，其中左子树与右子树的高度因子之差称为平衡因子。

> 红黑树

红黑树的三个特点：1. 根节点和叶子节点都是黑色； 2. 任何上下相邻的两个节点不能同时为红色； 3. 任何节点到叶子节点，路上包含相同数量的黑色节点

红黑树的优势：
1. 具有 n 个节点的完全二叉树其高度不超过 logn，而红黑树上下最多红黑相间（黑的可以相邻），则高度不超过 2logn，高度低可以适合于大数据场景，不至于递归太深
2. 平衡二叉树为了保证深度差的平衡特性，在插入和删除时会有重平衡操作，效率没有红黑树直接删除和插入效率高
3. 红黑树插入、删除、查找性能稳定

> B 树

Balance-tree(多路平衡查找树)即B树，平衡的意思是左边和右边分布均匀。多路的意思是相对于二叉树而言的，二叉树就是二路搜索树，搜索时只有两条路，而B-Tree有多条路，即父节点有多个子节点，一棵树含有最多子节点的数叫阶数。

<img src="/b_tree.jpg" />

构建过程
每次插入一个值，以当前节点的子节点数不超过 B 树的阶数为标准，放入该节点的子节点处；如果超过阶数，则将当前节点的 [中间数] [向上分裂]

> B+ 树

目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。Mysql 对经典的 B+ 树结构进行了优化，增加了叶子节点处的指针，形成了一个循环链表，提升了区间访问的性能。

B 树 & B+树异同：

1. B+ 树中所有的元素都会出现在叶子节点上，叶子节点负责存储数据，上面的非叶子节点只起到索引的作用。进一步说,B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他节点只存放 key；

2. B+ 树的叶子节点形成一个单向链表，一个叶子节点通过指针指向下一个叶子节点；

3. B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

<img src= "/b+.jpg" />

优点
- 相比于二叉树，层级更少，搜索效率高；
- 相比于 B 树，一个节点对应一页，B 树会在每个节点存放数据，而 B+ 树可以在一个节点存储更多的 Key，要存储大量数据，B+ 树比 B     
  树高度更低，而且每次都在叶子节点搜索的 B+ 树，搜索更稳定。同时，mysql 优化的 B+ 树，双向链表有利于范围搜索和排序。

构建过程
每次插入值，当前节点含有key 超过阶数时，不仅中间数向上分裂，其还需要在叶子节点中存在，并且形成链表

哈希索引
哈希索引是将对应的键值通过哈希算法散列到不同的槽位，当散列冲突时，在该槽位对应上一个链表

特点
- 只能等值查询，不支持范围查询
- 无法通过索引优化排序
- 不出现哈希冲突时，查询效率高于 B+ 树索引

应用
- Memory 存储引擎
- InnoDB 的自适应哈希功能也会用到哈希存储

## 索引分类

主键索引（聚集索引、聚簇索引）（只能有一个）
针对表中的主键建立的索引，在建表时会默认自动创建一个主键索引。对应关键字：Primary

常规索引（非聚集索引）
为了快速定位、快速搜索特定数据而创建的索引

唯一索引
避免同一表中的某列数据中的值重复，创建唯一约束的时候也会创建一个唯一索引，关键字： Unique

全文索引
全文查找关键词，而非比较索引中的值，关键字： FullText

> InnoDB 索引类型

聚集索引（只有一个）
将数据与索引放在一起存储，索引结构的叶子节点保存了数据

规则：
- 如果一张表存在主键，则主键索引就是聚集索引
- 如果没有主键，将选择第一个唯一索引做聚集索引
- 如果没有主键索引也没有唯一索引，则 InnoDB 自动生成一个 rowid 作为隐藏的聚集索引

二级索引
将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键。

当一张表已经有了聚集索引，则剩下的列再作为索引列时自动变成二级索引，二级索引子节点挂载的不再是数据，而是对应的该行主键

数据查询过程
查询条件若不是主键，则先根据该查询条件对应的索引列查到叶子节点，根据叶子节点挂载的主键值，再【回表查询】去聚集索引中查对应的叶子节点，通过主键索引的主键值挂载的数据，返回。

结论：主键索引的查询速度比二级索引的速度快，因为少了回表查询的过程

InnoDB三层B+树存储量
已知：InnoDB 一页能存储 16kb 的数据，假设一行数据占 1kb，则一页（一个非叶子节点是一页）能存储 16 行数据，已知树的非叶子节点只存储主键和指针（分叉），指针占用大小为 6 位，而主键占用类型与数据类型有关（假设为 bgint，则8位），可以计算出，一页可以存储的主键数为 1170个，而分叉可以有 1171个，一个分叉就是一页，所以一共能存储主键 1171 * 16 = 18736，即两层 B+ 树能存储 1万8 条数据。

- 两层 B+ 树：1万8行记录
- 三层 B+ 树：两千万条数据

事实上，三层 B+ 树就不适合了，阿里文件说 500万 数据就要考虑分库分表了

# SQL性能分析
## 四种手段性能查看

SQL 执行频率
通过执行 show global status like 'Com_______'，可以查看当前数据库查询、插入等的频次，可以得知该数据库真实使用时是以哪方面为主。

慢查询日志
慢查询日志记录了所有执行时间超过 long_query_time （默认10秒）的查询语句。默认未开启，通过在 /etc/my.cnf 配置 slow_query_log = 1 开启慢查询功能。

 profile详情
可以记录每条 SQL 指令的耗时，通过 show profiles 查看所有 sql 耗时情况

explain执行计划
explain直接用在select语句的前面查看执行计划，Explain执行计划各字段的含义:

- id：表示查询时，执行select操作表的顺序（对于id相同的，执行顺序从上到下；对于id不同的，执行顺序按id大的先执行）
- type：表示连接类型，多表连接时，性能由好到坏依次：null、system、const、eq_ref、ref、range、index、all
- key：用到的哪个索引
- ...

## 索引查询优化原则

> 联合索引

由多个字段（列）组成的索引，创建时直接 `create index idx on tableName(A,B,C)` 即在字段 ABC 上创建了一个联合索引

联合索引存储结构：一个 B+ 树上，所有非叶子节点会存储全部的（三列）key，叶子节点会存储全部的key 和数据。按照 key 排序，如果字段一的key相同，则比较字段二，所以在查询时，如果没有带字段一查询条件，则联合索引从根节点就不会往下走，索引失效。

建议：在业务场景下，当查询涉及到多个字段，建议使用联合索引。 


> 最左匹配原则

​ 如果索引了多个列，要遵循最左前缀法则，查询从索引的最左前列开始，并且不能跳过索引中的列，否则后面的索引失效
- 若跳过最左列，索引全部失效
- 若跳过中间列，后面的索引失效

> 范围查询

如果在使用联合索引查询时，> 或 < 的查询条件会使后面的索引失效，业务允许的条件下最好用 >= 或 <=

> 运算操作

如果在查询时在索引列上使用运算，则索引列失效，可以用 explain 看执行时，是不是用上了索引列的功能

> 字符串不加单引号

如果索引列是字符串类型，在查询时不加单引号，会导致无法用上索引列

> 模糊查询

模糊查询时，如果前面加模糊匹配，则索引列失效：`explain select * from tableName where name like '%ye'`

后面加模糊匹配，索引列有效：`explain select * from tableName where name like 'fei%'`

在大数据查询时，需要避免前面加模糊匹配的情况

> Or 连接原则

or 前后连接的查询条件，有一边没有索引，则全部索引失效

> 数据分布影响

如果通过索引查询的数据占了全表的大部分则不走索引直接全表扫描，看查询效率，数据库会选择走全表扫描还是走索引

> SQL提示

人为建议数据库用哪个索引 `select * from tableName use index(idx_user) where name like 'fei%'`

> 覆盖索引

指查询的字段都可以从当前索引树获取结果，而不需要回表查询，如 `select id，name from table where name = 'feiye'`，在查询时，只需要查索引列 name，因为 name 列的 B+ 树叶子节点存储了主键 id 和 name，所以不需要回表查询聚集索引，这就是覆盖索引 

> 前缀索引

如果某列是长串字符串或者大文本字段，建立索引列时，不必要把整个内容都作为key，可以建立前缀索引节省空间。

`create index idx_emial on tableEmail(email(5))`,其中 5 表示截取前五个字符作为前缀索引。

因为前缀索引只保留了前缀，所以 B+ 树的叶子节点未完全覆盖，还需要回表查询。

## 索引设计原则
- 对于查询频繁，数据量大的表建立索引
- 针对常作为 查询条件（where）、排序（order by）、分组（group by）的列建立索引
- 尽量选区分度较高的列建立索引，尤其是唯一索引区分度越高效率越高，反面教材性别 男女不能建立索引，性能太差
- 字符串类型的字段，长可以建前缀索引
- 尽量联合索引
- 索引不能存 NUll，建表时需要索引的列需要 not null

# SQL优化
## 插入insert优化

- 批量插入：一条条插入效率太低，改成一次插入多个，但一次插入最多上千；
- 手动事务提交：一次次批量插入会有一次次的事务提交，建议手动提交，执行多次插入再提交 `start transaction; ....; commit;`；
- 主键顺序插入，顺序插入效率高，不会出现各种页分裂与指针重新赋值的情况；
- 用 load 指令插入大批量数据，而不是 insert，见下面的面试题；


> 面试问题：如何一次性将大量数据导入数据库？

1，在连接mysql 客户端时，加上参数表明开启读本地文件 `mysql --local-infile -u root -p`

2，设置全局参数  `set global local_infile = 1`

3，执行 load 指令将准备好的数据导入表中 `load data local file '/root/sql.log' into table 'user' fields terminated by ',' lines terminated by '\n'`，即以文件中的逗号为分隔符，以文件中的换行为终止每句

## 主键优化

- 主键顺序插入的数据会一个个开辟新页，顺序放入，等页容量（16k）满了，建立新页，页与页之间，采用双向指针维护；
- 主键乱序插入会造成 【页分裂】 的现象，有开辟新页，欲插入页一半数据移动到新页，修改指针等环节，效率低；
- 页合并：某页被删除元素到阈值，则可能会发生两个页合并；

主键设计优化原则

- 主键长度尽量短
- 插入数据尽量顺序插入，选择使用 auto_increment 自增主键
- 尽量不用 uuid 或其他做主键
- 避免主键的修改

## 修改update优化

前提：修改索引列，事务执行加的行锁，修改非索引列，加的是表锁

- 行锁情况：update 更新数据时，如果事务A 正在对第2行修改，事务B 可以对其他行修改
- 表锁情况：update 更新数据时，如果事务A 正在对第2行修改，事务B 不可以对其他行修改

总结：尽量对索引列 update，避免行锁升级成表锁，降低并发性能

## order by排序优化

尽量使用带索引的列进行排序，可以在 explain 中查看 extra 的类型性能： using index > using filesort。

- using index 是指直接通过索引进行排序返回结果，性能高
- using filesort 是指将返回的结果在排序缓冲区排序

- 多字段排序时，也遵循最左匹配原则；
- 尽量使用覆盖索引；
- 建立的联合索引，默认是全部升序ASC，当多字段排序时，均按升序排是可以使用索引达到 using index 级别的，当多字段排序一个升序一个降序，还需要创建索引按一个升一个降创建；
- 如果大数据量排序，不可避免出现 filesort，可以适当增大缓冲区大小 sort_buffer_size（默认256k）

## limit 优化

分页查询，比如 limit(1000000, 10) 只查询一百万之后的10条数据

- 越往后效率越低，因为需要先对前面的数据排序，再只返回之后的n条数据
- 优化方式采用覆盖索引 + 子查询, 对覆盖索引全排序 + 只返回一定范围

先使用覆盖索引查出数据，再将该结果作为子表结合主表对应好外键多表联查

## group by分组优化

- 可以通过索引提高效率
- 分组操作的索引操作也符合最左匹配原则

## count 优化

- MyISAM 中记录了一个表的总行数在磁盘上，因此执行count(*) 效率高，直接返回；
- InnoDB 只能一行行读，计数，效率低；
- 当该字段某段为空，则不计数；

# 存储过程

## 概念

存储过程是为了避免应用服务器和数据库之间频繁的网络交互、提升效率，而通过调用在数据库里已经分封装好的接口实现功能，接口可以接收参数也可以返回数据。

# 触发器

## 概念

触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。

使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。


# 锁

分类

MySQL中的锁，按照锁的粒度分，分为以下三类:

- 全局锁:锁定数据库中的所有表。
- 表级锁:每次操作锁住整张表。
- 行级锁:每次操作锁住对应的行数据。

## 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML（操作：增删改查）的写语句、DDL（定义：增表、增字段） 语句、已经更新操作的事务提交语句都将被阻塞。但是此时数据库是可以读的。

其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。用于将整个数据库所有表数据备份到磁盘中。

如果在数据备份中不加全局表，很有可能发生的情况是在备份时仍有业务在处理且处理未完成，此时把处理了一半的业务备份完成，导致数据不一致的情况，即类似 A+B != 2000 的情况。

```sql
flush tables with read lock; -- 加全局锁
mysqldump -uroot -p1234 databasename > filename.sql; -- 备份操作，备份到指定文件
unlock tables; -- 解锁
```

## 表级锁

介绍

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MylSAM、InnoDB、BDB等存储引擎中。

对于表级锁，主要分为以下三类:

- 表锁
- 元数据锁( meta data lock, MDL)
- 意向锁

> 表锁

对于表锁，分为两类:

- 读锁：表共享读锁（ read lock )，某一客户端加了读锁，所有客户端都只能读，不能写；    
- 写锁：表独占写锁( write lock)，又叫排他锁、独占锁、写锁，某一客户端加了写锁，其可以读写，但其他客户端读写都被阻塞；

```sql
lock tables tablename read/write; -- 加锁
unlock tables; -- 解锁，客户端断开连接
```

> 元数据锁(meta data lock)(解决 DML 和 DDL 冲突)

MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。[为了避免DML与DDL冲突，保证读写的正确性。 ]

在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享);当对表结构进行变更操作的时候，加MDL写锁(排他)。

实际情况：事务 A 开启，执行增删改查命令，且目前事务 A 属于未提交状态，事务 B 可以使用增删改查，因为当前事务 A 和 B 都是共享锁，共享读锁和 共享写锁 兼容，但是 事务 B 不能修改表结构，因为修改表结构需要加互斥锁，其与共享锁不兼容，所以此时修改表结构操作会阻塞，直到 事务 A 提交完毕，事务 B 便可以修改表结构。

> 意向锁（解决表锁和行锁的冲突）

为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减
少表锁的检查。

意向锁的分类：

- 意向共享锁(IS)：与表锁共享锁（手动加的表读锁）兼容，与表锁排他锁（手动加的表写锁）互斥；
- 意向排他锁(IX )：与表锁共享锁和排他锁互斥，但意向锁之间兼容；

具体实现过程是：

- 当要加表锁时，判断当前意向锁与表锁是否兼容，否则需要等待事务 A 提交完毕释放锁才能加表锁；
- 当事务 A 实行读操作时加共享锁，会加上读锁并且自动加意向读锁，此时事务 B 可以进行加读锁，但不能加写锁会阻塞；
- 当事务 B 实行增删改操作时，默认会加上排他锁和意向排他锁，此时事务 B 无法进行加读锁和写锁；

## 行级锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在lnnoDB存储引擎中。

InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类:

- 行锁：锁住单个记录行，防止其他事物进行 删除 delete 和修改 update 操作，在 可重复读 和 读已提交 两种隔离级别下支持；
- 间隙锁：锁住记录间的间隙，防止中间有 插入 insert 操作，防止幻读，在可重复读 的隔离级别下支持；
- 临键锁：行锁和间隙锁的组合，锁住数据和之前的间隙，同时防止 增加、删除和修改操作，在可重复读 隔离级别下支持；

InnoDB 实现了两种类型的行锁：

- 共享锁(S)∶允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
- 排他锁（X)∶允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

默认加锁机制：

- 当事务执行 增删改操作时，数据库会自动加上 排他锁 + 意向锁排他锁 + 如果增删改唯一索引的具体行，不存在该数据时，加前后值的间隙锁防止幻读，存在时，加行锁；
- 增删改查普通索引时，也会自动加锁，加间隙锁，保证该行前后不会被其他事务插入同 id 的记录；
- 增删改查唯一索引但是是范围查询时，会在范围内加上间隙锁保证不会幻读；

- 当事务执行查询操作，不会加任何锁；
- 同时也可以手动加锁：用 select ... lock in share mode 加共享锁； 用 select ... for update 加排他锁；























  




