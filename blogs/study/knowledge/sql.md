---
title: SQL & Redis 面经篇
date: 2022-05-20
tags:
 - 数据库
categories:
 - 面经
---
<!-- TOC -->

- [MySQL的存储引擎](#mysql%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
- [Mysql的死锁](#mysql%E7%9A%84%E6%AD%BB%E9%94%81)
- [事务](#%E4%BA%8B%E5%8A%A1)
- [外键](#%E5%A4%96%E9%94%AE)
- [MySQL索引](#mysql%E7%B4%A2%E5%BC%95)
- [对Redis了解多吗？你觉得Redis最核心的功能是什么？](#%E5%AF%B9redis%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%90%97%E4%BD%A0%E8%A7%89%E5%BE%97redis%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88)
- [怎么防止缓存击穿的问题？](#%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%9A%84%E9%97%AE%E9%A2%98)
- [布隆过滤器的原理是什么？它的优点是什么？缺陷是什么？](#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%E6%98%AF%E4%BB%80%E4%B9%88)

<!-- /TOC -->
## MySQL的存储引擎

MySQL支持多种存储引擎，如InnoDB，MyISAM，Memory等，大多数情况下直接选用InnoDB即可，InnoDB也是MySQL的默认存储引擎。PS：MySQL 5.5之前的版本默认使用MyISAM，之后的版本默认使用InnoDB。

以下专门对InnoDB和MyISAM进行优劣对比：

1.InnoDB支持事务，MyISAM不支持；

2.InnoDB支持外键，MyISAM不支持；INnoDB采用聚集索引，使用B+Tree作为索引结构，数据结构和索引捆绑，所以其必须有主键，而MyISAM是非聚集索引，也是使用B+Tree，但索引和数据文件分开，不必须有主键。

3.InnoDB支持表级锁、行级锁(默认)，MyISAM只支持表级锁。InnoDB的锁力度小但并发能力高。针对多个并发和QPS较高的情况推荐InnoDB。

4.InnoDB支持MVCC，MyISAM不支持。

5.MyISAM支持全文索引，InnoDB不支持。5.7以后的InnoDB支持全文索引了。InnoDB不保存表的具体行数，在执行 select count(*) from table 时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。

场景选择

大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。

主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。

## Mysql的死锁

死锁概述

是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。 

一种情形，此时执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源。例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。

计算机系统中,如果系统的资源分配策略不当，更常见的可能是程序员写的程序有错误等，则会导致进程因竞争资源不当而产生死锁的现象。

锁有多种实现方式，比如意向锁，共享－排他锁，锁表，树形协议，时间戳协议等等。锁还有多种粒度，比如可以在表上加锁，也可以在记录上加锁。 

产生死锁的主要原因

```java
（1）系统资源不足。

（2）进程运行推进的顺序不合适。

（3）资源分配不当等。
```

如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

产生死锁的四个必要条件

```java
（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
```

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

常见的解决死锁的方法

- 1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

- 2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

- 3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

## 事务

InnoDB的事务具有四个特性（简称ACID）

- 原子性（Atomicity）
  
  数据要么一起成功，要么一起失败，即事务提交（commit）和事务回滚（rollback）。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

- 一致性（Consistency）

  一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。举例来说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。


- 隔离性（Isolation）

  隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

- 持久性（Durability）

  持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务已经正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成。否则的话就会造成我们虽然看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。这是不允许的。

Innodb中的事务隔离级别和锁的关系

数据库的一致性和隔离性一般使用加锁来保证，数据库是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。

因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。

数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）

- 加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。

- 解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

事务的隔离级别

- 未提交读(Read Uncommitted)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

- 提交读(Read Committed)：只能读取到已经提交的数据,可以阻止脏读，但是幻读或不可重复读仍有可能发生。Oracle等多数数据库默认都是该级别 (不重复读)

- 可重复读(Repeated Read)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。InnoDB默认级别。

- 串行读(Serializable)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

数据库事务并发问题

- 读未提交（read uncommitted）：三种并发问题都有可能出现，意味着可以读到未提交的事务修改的数据
  
- 读已提交（read committed）：解决了脏读问题，意味着没有提交的事务修改的数据不能读
  
- 可重复读（repeatable read）（默认）：解决了读未提交和不可重复读的问题
  
- 可串行化（serializable）：所有事务操作串行化，解决了三大问题，但是效率依次降低

上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。

## 外键
 
 外键的出现是因为两张表之间需要有关联，为了保证数据的完整性和唯一性而产生的。用来建立和加强两个表数据之间的连接。有外键时会有两张以上的表，分为主表和附表（父、子表）。附表中数据往往是主表中数据的延伸，附表中有外键关联到主表的主键上。

举例说明外键是如何通过将主表的主键与附表的外键建立关系的：

**建立主表 grade**

~~~shell
mysql> create table grade(
    -> id int(4) not null primary key,
    -> name varchar(36)
    -> );
~~~

**建立附表 student**

~~~shell
mysql> create table student (
    -> sid int(4) not null primary key,
    -> sname varchar(36),
    -> gid int(4) not null
    -> );
~~~

**建立外键约束关系**

~~~shell
mysql> alter table student add constraint FK_ID foreign key (gid) references grade (id);
~~~
其中FK_ID是随意定义的外键名。

**查看表**
~~~shell
mysql> desc grade;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(4)      | NO   | PRI | NULL    |       |
| name  | varchar(36) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.06 sec)

mysql> desc student;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| sid   | int(4)      | NO   | PRI | NULL    |       |
| sname | varchar(36) | YES  |     | NULL    |       |
| gid   | int(4)      | NO   | MUL | NULL    |       |
+-------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
~~~
可以看出，id为主键，gid为外键。但看不出两表之间的关系，进一步用show create table来看表的详细结构。

~~~shell
mysql> show create table student;
+---------+------------------------------------------------------------
| Table   | Create Table
+---------+------------------------------------------------------------
| student | CREATE TABLE `student` (
  `sid` int(4) NOT NULL,
  `sname` varchar(36) DEFAULT NULL,
  `gid` int(4) NOT NULL,
  PRIMARY KEY (`sid`),
  KEY `FK_ID` (`gid`),
  CONSTRAINT `FK_ID` FOREIGN KEY (`gid`) REFERENCES `grade` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+---------+------------------------------------------------------------
1 row in set (0.06 sec)
~~~

**完善表格数据**
~~~shell
+----+--------+
| id | name   |
+----+--------+
| 10 | 一班   |
| 11 | 二班   |
| 12 | 三班   |
+----+--------+

+-------+-----------+-----+
| sid   | sname     | gid |
+-------+-----------+-----+
|  1000 | 王一一    |  10 |
|  1001 | 黄婵      |  10 |
|  1002 | 关仙子    |  10 |
|  1003 | 绯夜      |  11 |
|  1004 | 聂香      |  11 |
+-------+-----------+-----+
~~~

**验证外键的作用**

`对于插入：`当外键存在时，附表添加的数据必须是主表存在的，比如这里，主表中有一班和二班，我们便不能向附表中插入三班的数据。

`对于删除：`可以单独删除 grade 表 id=12 的数据，但无法直接通过 delete 删除表 id=11 的数据，因为主表 id=11 的数据存在依赖。如需要删除，需要先将附表中的 id=11 的数据修改后才能删除 grade 中id=11 的内容，另外值得注意的是，在建立外键时，如果加上 on delete cascade，即：
~~~shell
mysql> alter table student add constraint FK_ID foreign key (gid) references grade (id) on delete cascade;
~~~
此时便可以级联删除，即删除主表数据的时候，与它相关联的附表数据也会一并删除。

**删除外键约束**

利用指令
~~~sql
alter table 表名 drop foreign key 外键名;
~~~
具体来说：
~~~shell
mysql> alter table student drop foreign key FK_ID;
~~~

## MySQL索引

四种索引类型

索引（Index）是帮助MySQL高效获取数据的数据结构。MyIASM和Innodb都使用了B+Tree这种数据结构做为索引。

- 主键(聚集)索引

- 非聚集索引

- 唯一索引

- 全文索引

## 对Redis了解多吗？你觉得Redis最核心的功能是什么？
自我理解
我认为 Redis 最核心的功能在于它作为缓存，能出色地应对 Mysql 所不能承受的高并发情况，我们知道，当并发请求过多，传统的 Mysql 数据库可能扛不住压力，造成缓存击穿的现象。而 Redis 每秒可承担十万 QPS。

扩展：
Redis 作为单线程运行，快的原因：
1. 内部支持的几种数据结构很高效： string、hash、list、set、zset；
2. Redis 操作完全基于内存，绝大多数操作的性能瓶颈不在 CPU；
3. 单线程模型，避免了上下文切换带来的性能开销；
4. 使用多路复用 I/O技术也能提升Redis的I/O利用率；

关于多路复用，这里的多路是指 多个网络连接客户端(多个套接字)，复用指的是复用同一个线程(单进程)。I/O 多路复用其实是使用一个线程来检查多个 Socket 的就绪状态，在单个线程中通过记录跟踪每一个 socket（I/O流）的状态来管理处理多个 I/O 流。

## 怎么防止缓存击穿的问题？
题目解析
击穿是指集中一点。指一个 key 非常热点。短时间该热点数据持续性大并发访问 redis，当该 key 失效的瞬间，大并发请求直接访问数据库进而击穿数据库导致数据库挂掉。
解决方案：
- 因为该 key 很热点，那就不对该 key 设置失效时间；
- 加互斥锁，在多个并发请求时，先让一个线程拿到锁，去查到数据更新至缓存，其他数据拿到锁查询缓存而非数据库；

## 布隆过滤器的原理是什么？它的优点是什么？缺陷是什么？

布隆过滤器由一个长度为 m 比特的位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。

布隆过滤器的原理：当一个元素被加入集合时，通过 k 个散列函数将这个元素映射到数组中的 k 个点中，把这些位置 置 1，在检索时，通过判断这些位置是否都为1：如果有0，则一定不存在；如果都是1，则可能存在；

至于说为什么都是 1 的情况只是可能存在检索元素，这是因为不同的元素计算的哈希值有可能一样，会出现哈希碰撞，导致一个不存在的元素有可能对应的比特位为 1。

优点：
- 节省空间：不需要存储对象，而只存储数组记录位置
- 速度快：哈希查询与插入的时间复杂度为 O(1) 

缺点：
- 失误性：可以用于判断一定不存在，但不能判断一定存在
- 不能删除元素：也是因为哈希冲突的问题，某一个位置置1，可能对应了多个元素存在的情况，如果置该位为0，会导致多个元素被判断不存在

应用：
- 应用于黑名单管理：布隆过滤器擅长的就是否定；
- 爬虫系统 url 去重
- 垃圾邮件过滤